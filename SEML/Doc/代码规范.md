# 前言

代码规范是一份优秀代码中必不可少的一部分，本代码规范参照了linux、rt-thread等优秀开源的代码规范对代码进行约定。

在Pull Requests时候会对代码规范和注释规范进行审查，如果不满足本代码规范会被打回，所以请严格遵守本代码规范。

# 目录

[TOC]

# 代码规范

**代码中使用的所有标点符号统一使用全英字符，如()  ,  ;  " "  ?  / 包括空格键，全部统一为全英半角字符。**

**代码风格[参考Linux风格](https://www.cnblogs.com/debugzhang/p/14580940.html)，做出如下规定：**

## 缩进

- - 缩进使用一个tab,且选择一个tab占两个空格,使得其效果和stm32的hal库保持一致同时不会太过占据屏幕空间。

  - switch和case保持相同缩进,如下图所示：

    ```c
    switch (i)
      {
      case 0:
        //code0
        break;
      case 1:
        //code1
        break;
      default:
      }
    ```

- 行的长度限制为 80列，若出现过长语句使用'\'进行打断换行。除非该行超过 80 列会显著提高可读性并且不会隐藏信息，长度超过80列的语句将被分成合理的块。后代始终比父代短很多，并且基本上位于右侧。具有长参数列表的函数头也是如此。并且参数保持对齐，例如：

  ```c
  //创建开始任务
  xTaskCreate((TaskFunction_t )start_task,            //任务函数
              (const char*    )"start_task",          //任务名称
              (uint16_t       )START_STK_SIZE,        //任务堆栈大小
              (void*          )NULL,                  //传递给任务函数的参数
              (UBaseType_t    )START_TASK_PRIO,       //任务优先级
              (TaskHandle_t*  )&StartTask_Handler);   //任务句柄 
  ```

- 对于宏定义，变量之类也尽可能保持对齐：

  ```c
  #define POWER_BUFFER_P    -2.0f
  #define POWER_BUFFER_I    0
  #define POWER_BUFFER_D    0
  #define POWER_BUFFER_PMAX 60.0f
  #define POWER_BUFFER_IMAX 0.0f
  #define POWER_BUFFER_DMAX 0.0f
  ```

- 不要把多个语句放在同一条中。

  ```c
  // 尽量不要这样
  if (/*表达式*/) /*code*/
  // 使用这种形式
  if (/*表达式*/)
    /*code*/
  ```

- 对于宏定义实现的伪函数，统一使用do{...}while(0)包裹起来，且用反斜杠(\\)来换行。

  ```c
  #define message_Pack_Update(pack, _update_tick) \
  	do                                          \
  	{                                           \
  		(pack)->update_tick = (_update_tick);   \
  	} while (0)
  ```

## 大括号和空格

- 所有大括号都单独起一行放置，不要和语句放在同一行。

- 在if, switch, case,     for, do, while这些关键词后面加个空格

- 对于只有一条代码的不需要使用花括号括起来

  ```c
  // 不要这样
    if (temp)  {   /* code */  }
  // 使用这种形式
    if (temp)  
    {
        /* code */  
    }
  // 对于单行代码
    if (temp)
        // code
  ```

- 不要在使用单个语句的地方不必要地使用大括号。

- 不要在带括号的表达式周围（内部）添加空格。这种不好的例子如下：

  ```c
  // 反例
  s = sizeof( struct file );
  // 正确写法
  s = sizeof(struct file);
  ```

- 在声明指针类型的数据或返回指针类型的函数时，*的首选用法是与数据名或函数名相邻，而不是与类型名相邻。例如：

  ```c
  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);
  void const * const pack;
  ```

- 在二元和三元运算符'= + - < > * / % | & ^ <= >= == != ? :'两侧加上空格，一元运算符'& * + - ~ !'前后不需要加入空格，使用 . 和 -> 运算符也不需要空格。

  ```c
     float halfnum = 0.5f * num;
     float y = num;
     long i = *(long*)&y;
     i = 0x5f3759df - (i >> 1);
     y = *(float*)&i;
     y = y * (1.5f - (halfnum * y * y));
     y = y * (1.5f - (halfnum * y * y));
     return y;
  ```

## 命名

对于所有的命名使用下划线对单词间进行分隔，对于拥有约定俗成的名称可以按照约定名称来。

- 全局函数命名应该用简要英文来表示该函数主要功能，使得看到该函数名即可得知其作用，良好的代码应是能做到自解释的。禁止使用拼音或者非约定俗称的缩写。

- 通常函数名采用首字母大写的形式。

  ```c
  // 不好的命名
  void XiaoXiRuDui(message_buffer_t *message_buffer_handle, uint8_t *data, uint16_t longth);
  void MB_EnQueue(message_buffer_t *message_buffer_handle, uint8_t *data, uint16_t longth);
  // 良好的命名
  void message_Buffer_EnQueue(message_buffer_t *message_buffer_handle, uint8_t *data, uint16_t longth);
  ```
  
- 全局变量（仅在确实需要它们时才使用）与全局函数一样，都需要使用具有描述性的名称命名。如果现在有一个函数用来统计活跃用户数，应该将它命名为 count_active_users() 或类似的，而不应该命名为 cntusr()。这种含糊不清的命名会严重阻碍代码的阅读。

- 局部变量名和应该简单明了，切中要害。如果你有一些随机的整数循环变量，可以将它命名为 i,j,k等，命名为 loop_counter 没有必要，因为i,j,k是约定俗成的循环计数变量，不会被误解。通常变量名越短代表其作用周期越短。

- 变量非约定俗称的采用小写字母来区分。

- 结构体、共用体、枚举、回调函数等重新使用`typedef`创建的类型需要以_t结尾，并且命名说明其主要含义。

- 类型非约定俗称的采用首字母大写来区分。

  ```c
  typedef struct
  {
  	void *data;				/**< 数据指针 */
  	uint16_t data_longth; 	/**< 数据长度 */
  	uint16_t cmd;			/**< 控制码 */
  } message_Data_Pack_t;
  /**
   * @brief 消息队列回调函数
   * @param config 回调函数配置句柄
   * @param id 接收到的消息id
   * @param cmd 接收到的消息控制码
   * @param data 接收到的数据
   */
  typedef void (*message_callback_fun_t)(void *config, message_Pack_t const *const message_pack);
  /**
   * @brief 消息列表错误码
   */
  typedef enum
  {
  	message_no_error,		/**< 无错误 */
  	message_mult_Register,	/**< 重复注册 */
  	message_list_full,		/**< 消息列表满 */
  	message_not_find,		/**< 未查找到 */
  	message_memory_failure, /**< 内存分配失败 */
  } message_error_code_t;
  ```

## 代码编写注意事项

### 代码模块化

在编程中，函数应该尽量精简，仅完成相对独立的简单功能。函数的实现不应该太长 ，函数实现太长，应该反思能够如何修改(或拆分)使得函数更为精简、易懂。一份精简的函数内容有助于后续开发者理解该代码作用。

### 不输出非必要的日志信息

要知道，输出日志信息对系统性能也是有所损耗的，所以请适当利用日志系统并且利用好日志系统的输出优先级。尽可能最小化日志系统对系统的性能损耗并且让日志信息易于调试。

### 非必要尽量不要使用动态内存

在嵌入式系统中由于内存通常较小，内存十分宝贵，使用动态内存如果出现内存泄漏、长期的申请释放所产生的内存碎片、大量申请不释放会导致内存分配失败，进而让系统运行不正常。并且内存分配问题通常并非在测试阶段能够提现出来的，而是在经过大量的申请释放后才会逐渐体现，这对bug定位是一个灾难。在军工级和医疗级产品是明确要求尽可能少使用动态内存，并且使用了动态内存的部分会经过严格审查以避免出现问题。

对于我们初学者在不熟悉内存机制的情况下尽可能不要使用是避免这种问题的最好办法。

### 关于goto

goto由于过于自由不被约束一直被程序员们诟病，甚至被许多公司直接禁用。但是goto本身就是一个十分好用的语法（在跳出多重循环，错误处理等方面十分实用），直接一刀切限制一个十分实用的工具也会导致代码变得复杂。在linux内核代码中大量存在goto，但是linux的代码依然十分优雅，其原因是**限制了goto只能在函数内跳转，且只能向后跳转**。在SEML库的开发中我们遵循该条限制，允许适当使用goto，在Pull Requests时会经过严格审查。

### 关于debug

debug一条首要原则是**从bug产生原因中修复而不是靠打补丁解决，如果不这么做会导致该系统依赖于此bug运行，从而形成屎山**。所以在发现了bug的时候应该反思为啥会导致此bug，并且准确定位修复，在Pull Requests需要注明是如何修复的，对于**含糊不清、答非所问**的更改描述会被打回重改。

# 注释规范

​		注释规范主要根据ST官方库文件里面的所有注释规范，再结合Doxygen的使用方式进行统一的规范，在SEML的开发和未来更新中，必须严格按照本注释规范进行代码的编写。

​		Doxygen的安装与使用可以参考[干货|教你使用Doxygen制作漂亮的程序文档 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/510925324)这位大佬的教程！！

## 函数内注释

​		源代码的注释不应该过多，更多的说明应该是代码做了什么，仅当个别关键点才需要一些相应提示性的注释以解释一段复杂的算法它是如何工作的。对语句的注释只能写在它的上方或右方，其他位置都是非法的。过于累赘的注释将浪费时间，且对代码理解作用不大，下面以rd-thread中的小内存管理模块为例：

```c
// 适当的注释
/**
 * @brief 这个函数将释放之前由rt_mem_alloc分配的内存块。释放的内存块被带回系统堆。
 * @param 要释放的内存地址。
 */
void rt_smem_free(void *rmem)
{
    struct rt_small_mem_item *mem;
    struct rt_small_mem *small_mem;

    if (rmem == RT_NULL)
        return;

    RT_ASSERT((((rt_ubase_t)rmem) & (RT_ALIGN_SIZE - 1)) == 0);

    /* 获取内存管理节点结构体 */
    mem = (struct rt_small_mem_item *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
    /* 对内存合法性进行检查 */
    small_mem = MEM_POOL(mem);
    RT_ASSERT(small_mem != RT_NULL);
    RT_ASSERT(MEM_ISUSED(mem));
    RT_ASSERT(rt_object_get_type(&small_mem->parent.parent) == RT_Object_Class_Memory);
    RT_ASSERT(rt_object_is_systemobject(&small_mem->parent.parent));
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)small_mem->heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)small_mem->heap_end);
    RT_ASSERT(MEM_POOL(&small_mem->heap_ptr[mem->next]) == small_mem);

    LOG_D("release memory 0x%x, size: %d",
            (rt_ubase_t)rmem,
            (rt_ubase_t)(mem->next - ((rt_uint8_t *)mem - small_mem->heap_ptr)));

    /* 将其使用状态设置为空闲 */
    mem->pool_ptr = MEM_FREED();
#ifdef RT_USING_MEMTRACE
    rt_smem_setname(mem, "    ");
#endif /* RT_USING_MEMTRACE */

    if (mem < small_mem->lfree)
    {
        /* 该节点为最低位空闲节点 */
        small_mem->lfree = mem;
    }

    small_mem->parent.used -= (mem->next - ((rt_uint8_t *)mem - small_mem->heap_ptr));

    /* 检查前后节点是否为空闲，如果是进行合并 */
    plug_holes(small_mem, mem);
}
// 过度注释
/**
 * @brief 这个函数将释放之前由rt_mem_alloc分配的内存块。释放的内存块被带回系统堆。
 * @param 要释放的内存地址。
 */
void rt_smem_free(void *rmem)
{
    struct rt_small_mem_item *mem;
    struct rt_small_mem *small_mem;
	/* 如果传入为空闲节点，不进行释放 */
    if (rmem == RT_NULL)
        return;
	/* 断言检查内存是否对齐，如果否进行断言 */
    RT_ASSERT((((rt_ubase_t)rmem) & (RT_ALIGN_SIZE - 1)) == 0);

    /* 获取内存管理节点结构体 */
    mem = (struct rt_small_mem_item *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
    /* 获取系统对象地址 */
    small_mem = MEM_POOL(mem);
    /* 断言检查系统对象为空 */
    RT_ASSERT(small_mem != RT_NULL);
    /* 断言检查该节点是否使用 */
    RT_ASSERT(MEM_ISUSED(mem));
    /* 断言检查该内存向内核对象管理注册的类型是否为RT_Object_Class_Memory */
    RT_ASSERT(rt_object_get_type(&small_mem->parent.parent) == RT_Object_Class_Memory);
    /* 断言检查该内核对象是否为系统对象 */
    RT_ASSERT(rt_object_is_systemobject(&small_mem->parent.parent));
    /* 断言检查该内存位于堆内 */
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)small_mem->heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)small_mem->heap_end);
    /* 断言检查下一个节点的系统对象是否一致 */
    RT_ASSERT(MEM_POOL(&small_mem->heap_ptr[mem->next]) == small_mem);
	/* 向日志系统输出debug级别的内容 */
    LOG_D("release memory 0x%x, size: %d",
            (rt_ubase_t)rmem,
            (rt_ubase_t)(mem->next - ((rt_uint8_t *)mem - small_mem->heap_ptr)));

    /* 将其使用状态设置为空闲 */
    mem->pool_ptr = MEM_FREED();
#ifdef RT_USING_MEMTRACE
    rt_smem_setname(mem, "    ");
#endif /* RT_USING_MEMTRACE */
	/* 如果该节点不是最低位空闲节点 */
    if (mem < small_mem->lfree)
    {
        /* 将其设置为最低为空闲节点 */
        small_mem->lfree = mem;
    }
	/* 将可用空间进行设置 */
    small_mem->parent.used -= (mem->next - ((rt_uint8_t *)mem - small_mem->heap_ptr));

    /* 检查前后节点是否为空闲，如果是进行合并 */
    plug_holes(small_mem, mem);
}
```

## 每一个头文件/源文件的文件注释

**每个头文件的首行开始必须包含以下注释：**

```c++
/**
 * @copyright (使用语言) 版权信息
 * @file 文件名
 * @author 作者
 * @brief 简介
 * @date 年-月-日
 *******************************************************************************
 * @par Change Log：
 *<table>
 *<tr><th>Date    <th>Version   <th>Author    <th>Description  
 *<tr><td>        <td>          <td>          <td>
 *<tr><td>        <td>          <td>          <td>
 *</table>
 *******************************************************************************
 * @details 细节
  ==============================================================================
                          	How to use this File  
  ==============================================================================
 *
 *
 *
 * @attention :注意事项
 */
```

**版权：** (使用语言 C/C++/...)  年份 --- 奇点机器人实验室

**文件名:** 与外部显示文件的命名要统一，还要加上文件类型的后缀。

**作者：**本文件的作者，姓名或者别名都可以 ，推荐使用英文名，如：Peng Kai，Echo,  Cand, Cio 等。

**简介：**简明介绍这个文件是用于什么方面的 包括但不限于：文件的使用目的，提供的内容，作用域等等。

**日期：**此文件的建立时间。

**更新日志：** 根据内容进行填写，Date 为此次文件版本更新的时间；Author 就是作者名字，与上述第三点作者名规范一致；Version 为本版号，统一为 x.x.x。例如，1.0.0表示软件的第一版，0.1.0表示在第一版的基础上进行了功能增加或改进，0.0.1表示在第一版的基础上进行了问题修复或细节优化；Notes 为此次版本更新的说明。最后自觉缩进对齐。

**细节：** 详细说明这个文档的使用方式以及介绍。

**注意事项：** 写明使用时需要注意的事项，没有统一填写 None。

实际使用例子(华南理工大学开源文档注释)：

```c++
/**
  ******************************************************************************
  * Copyright (c) 2019 - ~, SCUT-RobotLab Development Team
  * @file   : referee.cpp
  * @author : charlie 602894526@qq.com
  * @brief  : Code for communicating with Referee system of Robomaster 2019.
  * @date   : 2019-03-01
  * @par Change Log：
  *<table>
  *<tr><th>Date         <th>Version   <th>Author    <th>Description  
  *<tr><td>2019-03-01   <td>3.0.0     <td>kainan    <td>增加绘画类
  *<tr><td>2020-05-26   <td>4.0.0     <td>kainan    <td>适应20年规则
  *</table>
  *@details :
  ==============================================================================
                          How to use this driver  
  ==============================================================================
	Init()初始化模块
	
	裁判系统数据接收与外部读取
	1.使用unPackDataFromRF()解包裁判系统串口数据
	2.如果需要用到裁判系统提供的各种数据（具体有些什么数据请查看手册），读取相应结构体即可
	
  机器人车间通信
  1. 发送端调用CV_ToOtherRobot()发送数据
	2. 接收端轮询机器人ID对应的robot_com_data[]数据情况，如工程发送过来的数据为robot_com_data[1]

	操作手界面UI
	1.Set_DrawingLayer()设置图层，0-9
	2.对应的drawin()，clean()
	3.组合图形:标尺UI_ruler()、Draw_FitingGraph()
	4.注意：发数据给裁判系统。务必注意等待上电稳定之后才发送，否则会丢包 \n
					每个图形的name必须不同，建议name[3]不同即可 \n
	
	注意：
	串口DMA接收缓存数组大小建议设置等于256，过小容易造成解包过程数据被覆盖。
	发送需要和串口接收不同任务，由于速率控制内部有大量的vTaskDelay
	要等待一段时间(等串口、裁判系统稳定)，再发送clean、数据、UI等 
	特别注意要用最新的裁判系统客户端，旧版有点问题
	
	
  目前参考的是裁判系统串口协议附录V1.0-2020-02-25
  如有问题，请参考《RM2020裁判系统用户接口协议附录》
  2019年度裁判系统资料大全：
  https://bbs.robomaster.com/thread-7099-1-1.html
  ******************************************************************************
  * @attention:
  * 
  * if you had modified this file, please make sure your code does not have many 
  * bugs, update the version NO., write dowm your name and the date, the most
  * important is make sure the users will have clear and definite understanding 
  * through your new brief.
  ******************************************************************************
  */
```

## 结构体注释

```c++
/**
 * @brief 结构体的介绍
 * @details 详细描述，每一个类的作用，
 */
```

每一个结构体都做一些简要介绍即可，详细介绍可以根据实际情况进行说明。

​		注意：结构体内的每一个类，都必须注释清楚，说明这个类的作用，目的。

​					以下例子中的参数介绍使用到的 “  /*!< ” 注释方式后面会进行说明。

例如(STM官方的结构体介绍):

```c
/**
  * @brief  TIM One Pulse Mode Configuration Structure definition
  */
typedef struct
{
  uint32_t OCMode;        /*!< Specifies the TIM mode.
                               This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */

  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */

  uint32_t OCPolarity;    /*!< Specifies the output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */

  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t ICPolarity;    /*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */

  uint32_t ICSelection;   /*!< Specifies the input.
                              This parameter can be a value of @ref TIM_Input_Capture_Selection */

  uint32_t ICFilter;      /*!< Specifies the input capture filter.
                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
} TIM_OnePulse_InitTypeDef;

```

## 函数注释

```c++
/**
  * @brief 函数描述
  * @param[参数类型] 参数形参 参数描述
  * @return 返回值简要描述
  * @retval 返回值详细描述
  * @attention 注意事项
  */
```

**brief：**简单描述以下这个函数的作用即可，怎么用的，有什么效果。

**param:** 参数的描述，标明好参数类型（输入[in],输出[out],输入输出[in,out]），简单说明需要传入一个什么样的参数即可，若有多个参数，继续在下面添加@param。

**return:** 返回值的简要描述，说明返回的是一个什么东西即可，若有多个返回值，继续在下面添加@return。

**retval：** 特殊返回值，如枚举类型，列表等。

**attention:** 注意事项，说明使用该函数时需要注意什么。

实例如下( STM官方函数注释 )：

```c++
/**
  * @brief  Initializes the TIM Time base Unit according to the specified
  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->Base_MspInitCallback == NULL)
    {
      htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;

  return HAL_OK;
}

```

## 常量变量宏定义以及通用注释

```c
int a /**< 定义一个整型变量a */ 
int a /*!< 定义一个整型变量a */

#define __DASHUAIBI__ /**< 定义宏定义大帅逼*/
#define __DASHUAIBI__ /*!< 定义宏定义大帅逼*/

if( i == 1)
{
    a = b*2; /*对a进行赋值*/ 
}
```

需要注意的是，所有的变量，常量，结构体的类，局部变量，全局变量，宏定义等，都必须使用以上的注释方式，根据个人习惯二选一，目的是为了让Doxygen去生成说明文档；然后对一些写法的注释，如算法的介绍，过程的说明，写法的说明等，都必须使用/* ..... */的注释格式。

实例如下：

```c

#define TIM_CLEARINPUTSOURCE_NONE           0x00000000U   /*!< OCREF_CLR is disabled */
#define TIM_CLEARINPUTSOURCE_ETR            0x00000001U   /*!< OCREF_CLR is connected to ETRF input */

/**
  * @brief  HAL Active channel structures definition
  */
typedef enum
{
  HAL_TIM_ACTIVE_CHANNEL_1        = 0x01U,    /*!< The active channel is 1     */
  HAL_TIM_ACTIVE_CHANNEL_2        = 0x02U,    /*!< The active channel is 2     */
  HAL_TIM_ACTIVE_CHANNEL_3        = 0x04U,    /*!< The active channel is 3     */
  HAL_TIM_ACTIVE_CHANNEL_4        = 0x08U,    /*!< The active channel is 4     */
  HAL_TIM_ACTIVE_CHANNEL_CLEARED  = 0x00U     /*!< All active channels cleared */
} HAL_TIM_ActiveChannel;

/**
  * @brief  Initializes the TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  */
__weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspInit could be implemented in the user file
   */
}

```

## Modules 模块化分组

​	模块化分组是为了用Doxygen生成说明文档时，一模块化的方式显示在目录树上以下用到的都是模块定义的关键词。

```c
/**
 * @defgroup [gTag索引] [gName模块名]			
 * This is brief.
 * This is detail.
 * @{
 */
...
/** @} */

    
/**
 * @addtogroup [gTag同一模块的索引]
 * This is detail.
 * @{
 */
...
/** @} */
    
/**
 * @ingroup [gTag] 
 * This is brief.
 */
```

以上所有关键词的具体用法详情阅读以下这篇文章[(3条消息) 0-1 doxygen注释简规(分组)_doxygen 分组_孤梦无梦的博客-CSDN博客](https://blog.csdn.net/dreamonlysh/article/details/45002015)。

在本库中，我们统一以以下优先级为分组规范：

```c
/**
 * @addtogroup [gTag1  同一模块的索引] 英文命名
 * This is detail. 可以中文说明
 * @{
 */
 ...
/** @} */

```

# git 需求和审查

## Pull Requests

Pull Requests是避免出现屎山的最后保障，通常master分支是禁止修改的，只能通过Pull Requests进行合并，在修复bug、修改注释、添加新功能需要创建新分支，修改完成后提交Pull Requests请求，由审查人员对其代码进行审查。审查内容为分为**测试审查**和**代码审查**。

​	**测试审查：**指派专人(可以为提交者)运行是否有是否能够正常运行、功能是否正常、是否出现警告、错误并且经过极限测试(内核修改时候需要进行)，如果没有问题可以给予测试通过。

​	**代码审查：**代码审查通常为各组组长，主要审查代码规范、注释规范，Pull Requests提交说明是否足够清晰详细，没有问题可以给予测试通过。

需注意的是，如果打回需要注明为什么打回，需仔细说明原因，方便提交者整改。

## Issues

Issues用来提交需求和漏洞，以便进行任务分配和追踪。

Issues有如下标签：

- **bug**：漏洞，指在在测试和运行中发现的问题，需说明bug现象和复现条件。
- **enhancement**：增强，指对现有功能进行改进，需说明具体需求。
- **fecture**：功能，指新增的功能，需说明具体需求。
- **question**：问题，指对代码中的疑问或者对于使用方面的问题。
- **wontfix**：未修复，指该Issues是个bug，但是不准备修复。
- **invalid**：无效的，该需求不必要或者bug无法复现或者不是bug。
- **dupicate**：重复的，该需求之前提出过，需要评论指明之前重复的Issues。

前四个通常为新建issues时候使用的标签，后面三个通常为审查过后更改的标签。在提交issues时候需要打好标签，以便进行分类。

# 写在最后

一份良好且统一的代码规范有助于代码传承和维护，没有代码规范的代码无论一开始写的再好在经过多人协同维护以后终究会变成一坨屎山无人敢碰。在大部分互联网企业中代码规范也是面试考核的一部分，拥有良好的代码规范对以后就业也有一定的优势。

